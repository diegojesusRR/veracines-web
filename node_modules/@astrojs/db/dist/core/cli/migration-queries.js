import deepDiff from "deep-diff";
import { SQLiteAsyncDialect } from "drizzle-orm/sqlite-core";
import * as color from "kleur/colors";
import { customAlphabet } from "nanoid";
import stripAnsi from "strip-ansi";
import { hasPrimaryKey } from "../../runtime/index.js";
import {
  getCreateIndexQueries,
  getCreateTableQuery,
  getModifiers,
  getReferencesConfig,
  hasDefault,
  schemaTypeToSqlType
} from "../../runtime/queries.js";
import { isSerializedSQL } from "../../runtime/types.js";
import { safeFetch } from "../../runtime/utils.js";
import { MIGRATION_VERSION } from "../consts.js";
import { RENAME_COLUMN_ERROR, RENAME_TABLE_ERROR } from "../errors.js";
import { columnSchema } from "../schemas.js";
import {
} from "../types.js";
import { getRemoteDatabaseUrl } from "../utils.js";
const sqlite = new SQLiteAsyncDialect();
const genTempTableName = customAlphabet("abcdefghijklmnopqrstuvwxyz", 10);
async function getMigrationQueries({
  oldSnapshot,
  newSnapshot,
  reset = false
}) {
  const queries = [];
  const confirmations = [];
  if (reset) {
    const currentSnapshot = oldSnapshot;
    oldSnapshot = createEmptySnapshot();
    queries.push(...getDropTableQueriesForSnapshot(currentSnapshot));
  }
  const addedCollections = getAddedCollections(oldSnapshot, newSnapshot);
  const droppedTables = getDroppedCollections(oldSnapshot, newSnapshot);
  const notDeprecatedDroppedTables = Object.fromEntries(
    Object.entries(droppedTables).filter(([, table]) => !table.deprecated)
  );
  if (!isEmpty(addedCollections) && !isEmpty(notDeprecatedDroppedTables)) {
    throw new Error(
      RENAME_TABLE_ERROR(
        Object.keys(addedCollections)[0],
        Object.keys(notDeprecatedDroppedTables)[0]
      )
    );
  }
  for (const [collectionName, collection] of Object.entries(addedCollections)) {
    queries.push(getCreateTableQuery(collectionName, collection));
    queries.push(...getCreateIndexQueries(collectionName, collection));
  }
  for (const [collectionName] of Object.entries(droppedTables)) {
    const dropQuery = `DROP TABLE ${sqlite.escapeName(collectionName)}`;
    queries.push(dropQuery);
  }
  for (const [collectionName, newCollection] of Object.entries(newSnapshot.schema)) {
    const oldCollection = oldSnapshot.schema[collectionName];
    if (!oldCollection)
      continue;
    const addedColumns = getAdded(oldCollection.columns, newCollection.columns);
    const droppedColumns = getDropped(oldCollection.columns, newCollection.columns);
    const notDeprecatedDroppedColumns = Object.fromEntries(
      Object.entries(droppedColumns).filter(([, col]) => !col.schema.deprecated)
    );
    if (!isEmpty(addedColumns) && !isEmpty(notDeprecatedDroppedColumns)) {
      throw new Error(
        RENAME_COLUMN_ERROR(
          `${collectionName}.${Object.keys(addedColumns)[0]}`,
          `${collectionName}.${Object.keys(notDeprecatedDroppedColumns)[0]}`
        )
      );
    }
    const result = await getCollectionChangeQueries({
      collectionName,
      oldCollection,
      newCollection
    });
    queries.push(...result.queries);
    confirmations.push(...result.confirmations);
  }
  return { queries, confirmations };
}
async function getCollectionChangeQueries({
  collectionName,
  oldCollection,
  newCollection
}) {
  const queries = [];
  const confirmations = [];
  const updated = getUpdatedColumns(oldCollection.columns, newCollection.columns);
  const added = getAdded(oldCollection.columns, newCollection.columns);
  const dropped = getDropped(oldCollection.columns, newCollection.columns);
  const hasForeignKeyChanges = Boolean(
    deepDiff(oldCollection.foreignKeys, newCollection.foreignKeys)
  );
  if (!hasForeignKeyChanges && isEmpty(updated) && isEmpty(added) && isEmpty(dropped)) {
    return {
      queries: getChangeIndexQueries({
        collectionName,
        oldIndexes: oldCollection.indexes,
        newIndexes: newCollection.indexes
      }),
      confirmations
    };
  }
  if (!hasForeignKeyChanges && isEmpty(updated) && Object.values(dropped).every(canAlterTableDropColumn) && Object.values(added).every(canAlterTableAddColumn)) {
    queries.push(
      ...getAlterTableQueries(collectionName, added, dropped),
      ...getChangeIndexQueries({
        collectionName,
        oldIndexes: oldCollection.indexes,
        newIndexes: newCollection.indexes
      })
    );
    return { queries, confirmations };
  }
  const dataLossCheck = canRecreateTableWithoutDataLoss(added, updated);
  if (dataLossCheck.dataLoss) {
    const { reason, columnName } = dataLossCheck;
    const reasonMsgs = {
      "added-required": `You added new required column '${color.bold(
        collectionName + "." + columnName
      )}' with no default value.
      This cannot be executed on an existing table.`,
      "updated-type": `Updating existing column ${color.bold(
        collectionName + "." + columnName
      )} to a new type that cannot be handled automatically.`
    };
    confirmations.push(reasonMsgs[reason]);
  }
  const primaryKeyExists = Object.entries(newCollection.columns).find(
    ([, column]) => hasPrimaryKey(column)
  );
  const droppedPrimaryKey = Object.entries(dropped).find(([, column]) => hasPrimaryKey(column));
  const recreateTableQueries = getRecreateTableQueries({
    collectionName,
    newCollection,
    added,
    hasDataLoss: dataLossCheck.dataLoss,
    migrateHiddenPrimaryKey: !primaryKeyExists && !droppedPrimaryKey
  });
  queries.push(...recreateTableQueries, ...getCreateIndexQueries(collectionName, newCollection));
  return { queries, confirmations };
}
function getChangeIndexQueries({
  collectionName,
  oldIndexes = {},
  newIndexes = {}
}) {
  const added = getAdded(oldIndexes, newIndexes);
  const dropped = getDropped(oldIndexes, newIndexes);
  const updated = getUpdated(oldIndexes, newIndexes);
  Object.assign(dropped, updated);
  Object.assign(added, updated);
  const queries = [];
  for (const indexName of Object.keys(dropped)) {
    const dropQuery = `DROP INDEX ${sqlite.escapeName(indexName)}`;
    queries.push(dropQuery);
  }
  queries.push(...getCreateIndexQueries(collectionName, { indexes: added }));
  return queries;
}
function getAddedCollections(oldCollections, newCollections) {
  const added = {};
  for (const [key, newCollection] of Object.entries(newCollections.schema)) {
    if (!(key in oldCollections.schema))
      added[key] = newCollection;
  }
  return added;
}
function getDroppedCollections(oldCollections, newCollections) {
  const dropped = {};
  for (const [key, oldCollection] of Object.entries(oldCollections.schema)) {
    if (!(key in newCollections.schema))
      dropped[key] = oldCollection;
  }
  return dropped;
}
function getAlterTableQueries(unescapedCollectionName, added, dropped) {
  const queries = [];
  const collectionName = sqlite.escapeName(unescapedCollectionName);
  for (const [unescColumnName, column] of Object.entries(added)) {
    const columnName = sqlite.escapeName(unescColumnName);
    const type = schemaTypeToSqlType(column.type);
    const q = `ALTER TABLE ${collectionName} ADD COLUMN ${columnName} ${type}${getModifiers(
      columnName,
      column
    )}`;
    queries.push(q);
  }
  for (const unescColumnName of Object.keys(dropped)) {
    const columnName = sqlite.escapeName(unescColumnName);
    const q = `ALTER TABLE ${collectionName} DROP COLUMN ${columnName}`;
    queries.push(q);
  }
  return queries;
}
function getRecreateTableQueries({
  collectionName: unescCollectionName,
  newCollection,
  added,
  hasDataLoss,
  migrateHiddenPrimaryKey
}) {
  const unescTempName = `${unescCollectionName}_${genTempTableName()}`;
  const tempName = sqlite.escapeName(unescTempName);
  const collectionName = sqlite.escapeName(unescCollectionName);
  if (hasDataLoss) {
    return [
      `DROP TABLE ${collectionName}`,
      getCreateTableQuery(unescCollectionName, newCollection)
    ];
  }
  const newColumns = [...Object.keys(newCollection.columns)];
  if (migrateHiddenPrimaryKey) {
    newColumns.unshift("_id");
  }
  const escapedColumns = newColumns.filter((i) => !(i in added)).map((c) => sqlite.escapeName(c)).join(", ");
  return [
    getCreateTableQuery(unescTempName, newCollection),
    `INSERT INTO ${tempName} (${escapedColumns}) SELECT ${escapedColumns} FROM ${collectionName}`,
    `DROP TABLE ${collectionName}`,
    `ALTER TABLE ${tempName} RENAME TO ${collectionName}`
  ];
}
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function canAlterTableAddColumn(column) {
  if (column.schema.unique)
    return false;
  if (hasRuntimeDefault(column))
    return false;
  if (!column.schema.optional && !hasDefault(column))
    return false;
  if (hasPrimaryKey(column))
    return false;
  if (getReferencesConfig(column))
    return false;
  return true;
}
function canAlterTableDropColumn(column) {
  if (column.schema.unique)
    return false;
  if (hasPrimaryKey(column))
    return false;
  return true;
}
function canRecreateTableWithoutDataLoss(added, updated) {
  for (const [columnName, a] of Object.entries(added)) {
    if (hasPrimaryKey(a) && a.type !== "number" && !hasDefault(a)) {
      return { dataLoss: true, columnName, reason: "added-required" };
    }
    if (!a.schema.optional && !hasDefault(a)) {
      return { dataLoss: true, columnName, reason: "added-required" };
    }
  }
  for (const [columnName, u] of Object.entries(updated)) {
    if (u.old.type !== u.new.type && !canChangeTypeWithoutQuery(u.old, u.new)) {
      return { dataLoss: true, columnName, reason: "updated-type" };
    }
  }
  return { dataLoss: false };
}
function getAdded(oldObj, newObj) {
  const added = {};
  for (const [key, value] of Object.entries(newObj)) {
    if (!(key in oldObj))
      added[key] = value;
  }
  return added;
}
function getDropped(oldObj, newObj) {
  const dropped = {};
  for (const [key, value] of Object.entries(oldObj)) {
    if (!(key in newObj))
      dropped[key] = value;
  }
  return dropped;
}
function getUpdated(oldObj, newObj) {
  const updated = {};
  for (const [key, value] of Object.entries(newObj)) {
    const oldValue = oldObj[key];
    if (!oldValue)
      continue;
    if (deepDiff(oldValue, value))
      updated[key] = value;
  }
  return updated;
}
function getUpdatedColumns(oldColumns, newColumns) {
  const updated = {};
  for (const [key, newColumn] of Object.entries(newColumns)) {
    let oldColumn = oldColumns[key];
    if (!oldColumn)
      continue;
    if (oldColumn.type !== newColumn.type && canChangeTypeWithoutQuery(oldColumn, newColumn)) {
      const asNewColumn = columnSchema.safeParse({
        type: newColumn.type,
        schema: oldColumn.schema
      });
      if (asNewColumn.success) {
        oldColumn = asNewColumn.data;
      }
    }
    const diff = deepDiff(oldColumn, newColumn);
    if (diff) {
      updated[key] = { old: oldColumn, new: newColumn };
    }
  }
  return updated;
}
const typeChangesWithoutQuery = [
  { from: "boolean", to: "number" },
  { from: "date", to: "text" },
  { from: "json", to: "text" }
];
function canChangeTypeWithoutQuery(oldColumn, newColumn) {
  return typeChangesWithoutQuery.some(
    ({ from, to }) => oldColumn.type === from && newColumn.type === to
  );
}
function hasRuntimeDefault(column) {
  return !!(column.schema.default && isSerializedSQL(column.schema.default));
}
async function getProductionCurrentSnapshot({
  appToken
}) {
  const url = new URL("/db/schema", getRemoteDatabaseUrl());
  const response = await safeFetch(
    url,
    {
      method: "POST",
      headers: new Headers({
        Authorization: `Bearer ${appToken}`
      })
    },
    async (res) => {
      console.error(`${url.toString()} failed: ${res.status} ${res.statusText}`);
      console.error(await res.text());
      throw new Error(`/db/schema fetch failed: ${res.status} ${res.statusText}`);
    }
  );
  const result = await response.json();
  if (!result.success) {
    console.error(`${url.toString()} unsuccessful`);
    console.error(await response.text());
    throw new Error(`/db/schema fetch unsuccessful`);
  }
  return result.data;
}
function getDropTableQueriesForSnapshot(snapshot) {
  const queries = [];
  for (const collectionName of Object.keys(snapshot.schema)) {
    const dropQuery = `DROP TABLE ${sqlite.escapeName(collectionName)}`;
    queries.unshift(dropQuery);
  }
  return queries;
}
function createCurrentSnapshot({ tables = {} }) {
  const schema = JSON.parse(JSON.stringify(tables));
  return { version: MIGRATION_VERSION, schema };
}
function createEmptySnapshot() {
  return { version: MIGRATION_VERSION, schema: {} };
}
function formatDataLossMessage(confirmations, isColor = true) {
  const messages = [];
  messages.push(color.red("\u2716 We found some schema changes that cannot be handled automatically:"));
  messages.push(``);
  messages.push(...confirmations.map((m, i) => color.red(`  (${i + 1}) `) + m));
  messages.push(``);
  messages.push(`To resolve, revert these changes or update your schema, and re-run the command.`);
  messages.push(
    `You may also run 'astro db push --force-reset' to ignore all warnings and force-push your local database schema to production instead. All data will be lost and the database will be reset.`
  );
  let finalMessage = messages.join("\n");
  if (!isColor) {
    finalMessage = stripAnsi(finalMessage);
  }
  return finalMessage;
}
export {
  createCurrentSnapshot,
  createEmptySnapshot,
  formatDataLossMessage,
  getCollectionChangeQueries,
  getMigrationQueries,
  getProductionCurrentSnapshot
};
